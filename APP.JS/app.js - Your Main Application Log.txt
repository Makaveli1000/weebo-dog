// app.js - Your Main Application Logic

// --- 1. Firebase SDK Imports ---
// These import statements require the Firebase SDK to be installed in your project.
// If you haven't already, run 'npm install firebase qrcode.js' in your project directory.
import { initializeApp } from 'firebase/app';
import { getAuth, onAuthStateChanged, signInWithEmailAndPassword, createUserWithEmailAndPassword, signOut, updatePassword as authUpdatePassword } from 'firebase/auth'; // Added updatePassword
import { getFirestore, doc, getDoc, setDoc, onSnapshot, collection, addDoc, serverTimestamp, query, orderBy, limit, updateDoc } from 'firebase/firestore'; // Added updateDoc
import { getStorage, ref as storageRef, uploadBytes, getDownloadURL, listAll } from 'firebase/storage';

// --- 2. Retrieve Firebase Config from env-config.js ---
// This assumes your netlify.toml is correctly setting window.__firebase_config
// and env-config.js is loaded BEFORE app.js in index.html.
const firebaseConfig = window.__firebase_config;
const geminiApiKey = window.GEMINI_API_KEY; // Assuming Gemini API key is also passed this way

// --- 3. Initial Configuration Check ---
if (!firebaseConfig || !firebaseConfig.apiKey) {
    console.error("ðŸ”¥ Error: Firebase configuration not found or incomplete. Check env-config.js and Netlify build process.");
    // Update loading overlay to show an error
    const loadingOverlay = document.getElementById('loading-overlay');
    if (loadingOverlay) {
        loadingOverlay.innerHTML = `
            <div class="text-center text-red-700">
                <p class="text-xl font-bold mb-2">Configuration Error!</p>
                <p>Firebase setup is incomplete. Check browser console for details.</p>
                <p class="text-sm mt-2">Is 'env-config.js' loaded? Are Netlify env vars correct?</p>
            </div>
        `;
        loadingOverlay.style.backgroundColor = 'rgba(255, 0, 0, 0.9)'; // More opaque red background
    }
    // Prevent further execution if config is critically missing
    throw new Error("Firebase configuration is missing or malformed. Cannot initialize app.");
}

// --- 4. Initialize Firebase App and Services ---
const app = initializeApp(firebaseConfig);
const auth = getAuth(app);
const db = getFirestore(app);
const storage = getStorage(app);

// Global variables for convenience (can be managed better in larger apps)
let currentUser = null;
let currentUserID = null;
let userIsPro = false; // Flag for PRO membership status

console.log("âœ… Firebase app initialized successfully!");
console.log("Project ID:", firebaseConfig.projectId);
// Update debug info in HTML
document.addEventListener('DOMContentLoaded', () => {
    document.getElementById('debug-firebase-config').querySelector('span').textContent = firebaseConfig.projectId ? 'Loaded' : 'Error';
    document.getElementById('debug-app-id').querySelector('span').textContent = firebaseConfig.appId || 'N/A';
});


// --- 5. UI Element References (Caching for performance) ---
// It's good practice to get references to elements once the DOM is ready.
// This is done in the DOMContentLoaded listener further down.
let loadingOverlay, mainContent, paywallContent, loginModal, accountModal;
let headerAuthBtn, accountBtn, adminBtn;
let userStatusDisplay, userIdDisplay, accountUID, accountPremiumStatus;
let ttsButton, ttsStatus, ttsInput;
let lockerUploadBtn, mediaFileInput, lockerMediaDisplay, lockerStatusText;
let loginQrIdInput, qrcodeContainer; // For QR elements

// Function to safely get elements after DOM is loaded
function cacheDOMElements() {
    loadingOverlay = document.getElementById('loading-overlay');
    mainContent = document.getElementById('main-content');
    paywallContent = document.getElementById('paywall-content');
    loginModal = document.getElementById('login-modal');
    accountModal = document.getElementById('account-modal');
    headerAuthBtn = document.getElementById('header-auth-btn');
    accountBtn = document.getElementById('account-btn');
    adminBtn = document.getElementById('admin-btn');
    userStatusDisplay = document.getElementById('user-status-display');
    userIdDisplay = document.getElementById('user-id-display');
    accountUID = document.getElementById('account-uid');
    accountPremiumStatus = document.getElementById('account-premium-status');
    ttsButton = document.getElementById('tts-button');
    ttsStatus = document.getElementById('tts-status');
    ttsInput = document.getElementById('tts-input');
    lockerUploadBtn = document.getElementById('locker-upload-btn');
    mediaFileInput = document.getElementById('media-file-input');
    lockerMediaDisplay = document.getElementById('locker-media-display');
    lockerStatusText = document.getElementById('locker-status-text');
    loginQrIdInput = document.getElementById('login-qr-id-input');
    qrcodeContainer = document.getElementById('qrcode-container');
}


// --- 6. Core Application Functions ---

/**
 * Hides the loading overlay and shows appropriate content based on user state.
 */
function hideLoadingOverlayAndShowContent() {
    if (loadingOverlay) {
        loadingOverlay.classList.add('hidden');
    }

    // Logic to show main content or paywall
    if (currentUser && userIsPro) {
        mainContent.classList.remove('hidden');
        paywallContent.classList.add('hidden');
    } else if (currentUser && !userIsPro) {
        // Logged in but not Pro, show main content but some features might be locked
        mainContent.classList.remove('hidden');
        paywallContent.classList.add('hidden');
        // You might want to display a message or disable PRO features here
    }
    else { // Not logged in
        mainContent.classList.add('hidden');
        paywallContent.classList.remove('hidden');
    }
}

/**
 * Toggles the visibility of the login modal.
 * @param {boolean} show - True to show, false to hide.
 */
window.toggleLoginModal = (show) => {
    if (loginModal) {
        if (show) loginModal.classList.remove('hidden');
        else loginModal.classList.add('hidden');
    }
};

/**
 * Toggles the visibility of the account modal.
 * @param {boolean} show - True to show, false to hide.
 */
window.toggleAccountModal = (show) => {
    if (accountModal) {
        if (show) accountModal.classList.remove('hidden');
        else accountModal.classList.add('hidden');
    }
};

/**
 * Authenticates a user with email and password.
 */
window.logIn = async () => {
    const email = document.getElementById('login-email').value;
    const password = document.getElementById('login-password').value;
    const loginError = document.getElementById('login-error');

    if (!email || !password) {
        loginError.textContent = "Email and password are required.";
        return;
    }

    try {
        loginError.textContent = ""; // Clear previous errors
        await signInWithEmailAndPassword(auth, email, password);
        console.log("User logged in successfully!");
        toggleLoginModal(false); // Close modal on success
    } catch (error) {
        console.error("Login failed:", error.code, error.message);
        loginError.textContent = `Login failed: ${error.message}`;
    }
};

/**
 * Registers a new user with email and password.
 */
window.register = async () => {
    const email = document.getElementById('login-email').value;
    const password = document.getElementById('login-password').value;
    const loginError = document.getElementById('login-error');

    if (!email || !password || password.length < 6) {
        loginError.textContent = "Email and a password of at least 6 characters are required.";
        return;
    }

    try {
        loginError.textContent = ""; // Clear previous errors
        const userCredential = await createUserWithEmailAndPassword(auth, email, password);
        console.log("User registered successfully:", userCredential.user.uid);
        // Create a user profile in Firestore
        await setDoc(doc(db, "users", userCredential.user.uid), {
            uid: userCredential.user.uid,
            email: userCredential.user.email,
            nickname: email.split('@')[0], // Default nickname
            isPro: false,
            createdAt: serverTimestamp()
        });
        toggleLoginModal(false); // Close modal on success
    } catch (error) {
        console.error("Registration failed:", error.code, error.message);
        loginError.textContent = `Registration failed: ${error.message}`;
    }
};

/**
 * Logs out the current user.
 */
window.logOut = async () => {
    try {
        await signOut(auth);
        console.log("User logged out successfully!");
        // UI updates handled by onAuthStateChanged listener
    } catch (error) {
        console.error("Logout failed:", error.code, error.message);
    }
};

/**
 * Saves the user's nickname to Firestore.
 */
window.saveAccountNickname = async () => {
    const nicknameInput = document.getElementById('account-nickname');
    if (!currentUser || !nicknameInput) return;

    const newNickname = nicknameInput.value.trim();
    if (newNickname === '') {
        alert("Nickname cannot be empty.");
        return;
    }

    try {
        const userDocRef = doc(db, "users", currentUser.uid);
        await updateDoc(userDocRef, { nickname: newNickname });
        console.log("Nickname updated successfully!");
        alert("Nickname saved!");
    } catch (error) {
        console.error("Error updating nickname:", error);
        alert(`Failed to save nickname: ${error.message}`);
    }
};

/**
 * Updates the user's password.
 */
window.updateUserPassword = async () => {
    const newPasswordInput = document.getElementById('account-new-password');
    const passwordError = document.getElementById('account-password-error');
    if (!currentUser || !newPasswordInput) return;

    const newPassword = newPasswordInput.value;
    if (newPassword.length < 6) {
        passwordError.textContent = "Password must be at least 6 characters.";
        return;
    }

    try {
        passwordError.textContent = "";
        await authUpdatePassword(currentUser, newPassword);
        console.log("Password updated successfully!");
        alert("Password updated! Please log in again with your new password.");
        await signOut(auth); // Force re-login after password change
        toggleAccountModal(false);
        toggleLoginModal(true);
    } catch (error) {
        console.error("Error updating password:", error);
        passwordError.textContent = `Failed to update password: ${error.message}`;
    }
};


// Placeholder for other functions - you will fill these in!
window.toggleAdminModal = (show) => { console.log('Admin modal functionality not implemented yet.'); /* Implement actual logic */ };
window.toggleCashAppModal = (show) => { console.log('CashApp modal functionality not implemented yet.'); /* Implement actual logic */ };
window.startZeusNarratorTour = () => { console.log('Zeus Narrator Tour not implemented yet.'); /* Implement actual logic */ };
window.toggleSportsDataModal = (show) => { console.log('Sports Data modal functionality not implemented yet.'); /* Implement actual logic */ };
window.copyQrCodeText = () => {
    if (loginQrIdInput && loginQrIdInput.value) {
        navigator.clipboard.writeText(loginQrIdInput.value)
            .then(() => {
                alert('User ID copied to clipboard!');
            })
            .catch(err => {
                console.error('Failed to copy text: ', err);
            });
    }
};

window.sendMessage = async (type, content) => {
    if (!currentUserID) {
        alert("You must be logged in to send messages.");
        return;
    }
    const messageInput = document.getElementById('message-input');
    const chatModeToggle = document.getElementById('chat-mode-toggle');
    const recipientIdInput = document.getElementById('recipient-id-input');

    let messageText = messageInput.value.trim();
    if (messageText === '') return;

    try {
        await addDoc(collection(db, "chatMessages"), {
            uid: currentUserID,
            senderNickname: (await getDoc(doc(db, "users", currentUserID))).data()?.nickname || 'Anon',
            text: messageText,
            timestamp: serverTimestamp(),
            type: type, // 'text', 'VIDEO_REQUEST', etc.
            chatType: chatModeToggle.value, // 'public' or 'private'
            recipientId: chatModeToggle.value === 'private' ? recipientIdInput.value : null
        });
        messageInput.value = ''; // Clear input
    } catch (error) {
        console.error("Error sending message:", error);
        alert("Failed to send message.");
    }
};

window.toggleChatMode = () => {
    const chatModeToggle = document.getElementById('chat-mode-toggle');
    const recipientContainer = document.getElementById('recipient-container');
    const recipientIdInput = document.getElementById('recipient-id-input');
    const videoCallBtn = document.getElementById('video-call-btn');

    if (chatModeToggle.value === 'private') {
        recipientContainer.classList.remove('hidden');
        recipientIdInput.classList.remove('hidden');
        videoCallBtn.classList.remove('hidden');
    } else {
        recipientContainer.classList.add('hidden');
        recipientIdInput.classList.add('hidden');
        videoCallBtn.classList.add('hidden');
        recipientIdInput.value = ''; // Clear recipient when switching to public
    }
};

window.handleFileUpload = async () => {
    if (!currentUser) {
        console.warn("Cannot upload: User not logged in.");
        // Optionally show message to user
        alert("Please log in to upload media.");
        return;
    }
    if (!mediaFileInput || mediaFileInput.files.length === 0) {
        console.warn("No file selected for upload.");
        return;
    }
    const file = mediaFileInput.files[0];
    const filePath = `user_media/${currentUser.uid}/${file.name}`;
    const fileRef = storageRef(storage, filePath);

    try {
        console.log(`Uploading ${file.name}...`);
        // You might want to show a loading indicator here
        await uploadBytes(fileRef, file);
        const fileURL = await getDownloadURL(fileRef);
        console.log("File uploaded, URL:", fileURL);

        // Save file metadata to Firestore (e.g., in a 'user_files' subcollection)
        await addDoc(collection(db, "users", currentUser.uid, "media"), {
            name: file.name,
            url: fileURL,
            uploadedAt: serverTimestamp(),
            type: file.type
        });
        console.log("File metadata saved to Firestore.");
        alert("File uploaded successfully!");
        loadUserMedia(); // Refresh media display
    } catch (error) {
        console.error("File upload failed:", error);
        alert(`Upload failed: ${error.message}`);
    }
};


// --- 7. Real-time Listeners and Data Loading ---

// Listen for authentication state changes
onAuthStateChanged(auth, async (user) => {
    currentUser = user; // Update global user object
    currentUserID = user ? user.uid : null;

    if (user) {
        console.log("User state changed: Logged in", user.uid);
        if (userStatusDisplay) userStatusDisplay.textContent = 'Logged In';
        if (userIdDisplay) userIdDisplay.textContent = user.uid.substring(0, 8); // Display first 8 chars
        if (headerAuthBtn) headerAuthBtn.classList.add('hidden');
        if (accountBtn) accountBtn.classList.remove('hidden');
        if (lockerUploadBtn) lockerUploadBtn.disabled = false;
        if (accountUID) accountUID.textContent = user.uid;

        // Fetch user profile from Firestore to get isPro status
        const userDocRef = doc(db, "users", user.uid);
        const userDocSnap = await getDoc(userDocRef);
        if (userDocSnap.exists()) {
            const userData = userDocSnap.data();
            userIsPro = userData.isPro || false; // Default to false if not set
            if (accountPremiumStatus) accountPremiumStatus.textContent = userIsPro ? 'PRO Member' : 'Standard User';
            if (userData.nickname) {
                 document.getElementById('account-nickname').value = userData.nickname;
            }
        } else {
            console.warn("User profile not found in Firestore, creating basic entry.");
            // This case should ideally be covered by register(), but good fallback
            await setDoc(userDocRef, {
                uid: user.uid,
                email: user.email,
                nickname: user.email.split('@')[0],
                isPro: false,
                createdAt: serverTimestamp()
            }, { merge: true }); // Use merge to not overwrite existing fields
            userIsPro = false;
            if (accountPremiumStatus) accountPremiumStatus.textContent = 'Standard User';
            if (document.getElementById('account-nickname')) document.getElementById('account-nickname').value = user.email.split('@')[0];
        }

        // After all user data is loaded and state is set
        hideLoadingOverlayAndShowContent();
        loadActiveUsers();
        loadLiveFeed();
        loadChatMessages();
        loadCommunityScoreboard();
        loadUserMedia(); // Load user's media for locker
        // Other data loads that require authentication
    } else {
        console.log("User state changed: Logged out");
        if (userStatusDisplay) userStatusDisplay.textContent = 'Logged Out';
        if (userIdDisplay) userIdDisplay.textContent = '';
        if (headerAuthBtn) headerAuthBtn.classList.remove('hidden');
        if (accountBtn) accountBtn.classList.add('hidden');
        if (lockerUploadBtn) lockerUploadBtn.disabled = true;
        if (accountUID) accountUID.textContent = 'N/A';
        if (accountPremiumStatus) accountPremiumStatus.textContent = 'N/A';
        userIsPro = false;

        // After auth state is determined
        hideLoadingOverlayAndShowContent();
        loadActiveUsers(); // Active users might still be public
        loadLiveFeed(); // Live feed might still be public
        // Clear private data displays
        if (lockerMediaDisplay) lockerMediaDisplay.innerHTML = '<p class="text-center text-gray-500">Log in to view your media.</p>';
    }
});


// Live Feed Listener (assuming 'liveFeed' collection is publicly readable)
function loadLiveFeed() {
    const liveFeedRef = doc(db, "liveFeed", "latestScore"); // Document ID 'latestScore'
    const latestDataEl = document.getElementById('latest-data');
    const dataStreamEl = document.getElementById('data-stream');

    if (!latestDataEl || !dataStreamEl) return; // Prevent errors if elements aren't found

    onSnapshot(liveFeedRef, (docSnap) => {
        if (docSnap.exists()) {
            const data = docSnap.data();
            latestDataEl.textContent = data.score || "No score update.";
            dataStreamEl.textContent = JSON.stringify(data, null, 2);
            console.log("Live Feed updated:", data);
        } else {
            latestDataEl.textContent = "No live data available.";
            dataStreamEl.textContent = "No 'latestScore' document found in 'liveFeed' collection.";
            console.warn("No 'latestScore' document in 'liveFeed' collection.");
        }
    }, (error) => {
        console.error("Error loading live feed:", error);
        const statusMessageEl = document.getElementById('status-message');
        const statusMessageContainerEl = document.getElementById('status-message-container');
        if (statusMessageEl && statusMessageContainerEl) {
            statusMessageEl.textContent = `Error loading live feed: ${error.message}`;
            statusMessageContainerEl.classList.remove('hidden');
        }
    });
}

// Active Users Listener (assuming 'presence' collection is publicly readable)
function loadActiveUsers() {
    const activeUsersList = document.getElementById('active-users-list');
    if (!activeUsersList) return;

    const q = query(collection(db, "presence"), orderBy("lastSeen", "desc"), limit(10)); // Order by last seen, limit to 10
    onSnapshot(q, (snapshot) => {
        activeUsersList.innerHTML = ''; // Clear previous list
        snapshot.forEach((doc) => {
            const userData = doc.data();
            if (userData.nickname && userData.lastSeen) { // Ensure nickname and lastSeen exist
                const li = document.createElement('li');
                li.className = 'flex items-center space-x-2 p-2 bg-gray-50 rounded-md';
                // Calculate time difference for 'min ago'
                const lastSeenDate = userData.lastSeen.toDate();
                const minutesAgo = Math.round((Date.now() - lastSeenDate) / 60000); // in minutes
                li.innerHTML = `
                    <span class="w-2 h-2 rounded-full ${minutesAgo < 5 ? 'bg-green-500' : 'bg-yellow-500'}"></span>
                    <span>${userData.nickname}</span>
                    <span class="text-xs text-gray-400">(${minutesAgo} min ago)</span>
                `;
                activeUsersList.appendChild(li);
            }
        });
        if (snapshot.empty) {
            activeUsersList.innerHTML = '<p class="text-center text-gray-500 py-4">No active users.</p>';
        }
    }, (error) => {
        console.error("Error loading active users:", error);
    });
}

// Chat Messages Listener (assuming 'chatMessages' collection is publicly readable/writable for now)
function loadChatMessages() {
    const chatMessagesEl = document.getElementById('chat-messages');
    if (!chatMessagesEl) return;

    const q = query(collection(db, "chatMessages"), orderBy("timestamp", "asc"), limit(50));
    onSnapshot(q, (snapshot) => {
        chatMessagesEl.innerHTML = ''; // Clear previous messages
        snapshot.forEach((doc) => {
            const msg = doc.data();
            const p = document.createElement('p');
            p.className = `text-sm ${msg.uid === currentUserID ? 'text-right text-metro-primary' : 'text-left text-gray-800'}`;
            const time = msg.timestamp ? new Date(msg.timestamp.toDate()).toLocaleTimeString() : '';
            p.innerHTML = `<span class="font-semibold">${msg.senderNickname || 'Anon'}</span> <span class="text-gray-500 text-xs">${time}</span>: ${msg.text}`;
            chatMessagesEl.appendChild(p);
        });
        chatMessagesEl.scrollTop = chatMessagesEl.scrollHeight; // Auto-scroll to latest
    }, (error) => {
        console.error("Error loading chat messages:", error);
    });
}

// Community Scoreboard Listener (assuming 'sportsData' is publicly readable)
function loadCommunityScoreboard() {
    const sportsDataDisplay = document.getElementById('sports-data-display');
    if (!sportsDataDisplay) return;

    const q = query(collection(db, "sportsData"), orderBy("timestamp", "desc"), limit(10));
    onSnapshot(q, (snapshot) => {
        sportsDataDisplay.innerHTML = '';
        if (snapshot.empty) {
            sportsDataDisplay.innerHTML = '<p class="text-center text-gray-500 py-8 col-span-full">No sports data submitted yet.</p>';
        } else {
            snapshot.forEach((doc) => {
                const data = doc.data();
                const div = document.createElement('div');
                div.className = 'bg-gray-50 p-4 rounded-lg shadow-sm border border-gray-200';
                div.innerHTML = `
                    <p class="font-semibold text-lg">${data.sport}: ${data.score}</p>
                    <p class="text-sm text-gray-600">${data.team1} vs ${data.team2}</p>
                    <p class="text-xs text-gray-400">Submitted by ${data.submittedBy || 'Anon'} on ${new Date(data.timestamp.toDate()).toLocaleString()}</p>
                `;
                sportsDataDisplay.appendChild(div);
            });
        }
    }, (error) => {
        console.error("Error loading scoreboard:", error);
    });
}


// Function to load user's uploaded media
async function loadUserMedia() {
    if (!currentUser) {
        if (lockerMediaDisplay) lockerMediaDisplay.innerHTML = '<p class="text-center text-gray-500">Log in to view your media.</p>';
        if (lockerStatusText) lockerStatusText.textContent = 'Capacity: Log in to see status.';
        return;
    }
    if (lockerMediaDisplay) lockerMediaDisplay.innerHTML = '<p class="text-center text-gray-500">Loading your media...</p>';
    if (lockerStatusText) lockerStatusText.textContent = 'Capacity: Checking...';

    try {
        const mediaCollectionRef = collection(db, "users", currentUser.uid, "media");
        const q = query(mediaCollectionRef, orderBy("uploadedAt", "desc"), limit(10)); // Limit to 10 for example
        onSnapshot(q, (snapshot) => {
            if (lockerMediaDisplay) lockerMediaDisplay.innerHTML = ''; // Clear previous media
            snapshot.forEach((doc) => {
                const media = doc.data();
                const div = document.createElement('div');
                div.className = 'relative group';
                // Basic image display, enhance with video/other types as needed
                if (media.type && media.type.startsWith('image/')) {
                    div.innerHTML = `<img src="${media.url}" alt="${media.name}" class="w-full h-32 object-cover rounded-lg shadow">`;
                } else {
                     div.innerHTML = `<a href="${media.url}" target="_blank" class="block w-full h-32 bg-gray-200 flex items-center justify-center rounded-lg shadow text-gray-600">Download ${media.name}</a>`;
                }
                if (lockerMediaDisplay) lockerMediaDisplay.appendChild(div);
            });
            if (snapshot.empty && lockerMediaDisplay) {
                lockerMediaDisplay.innerHTML = '<p class="text-center text-gray-500">No media uploaded yet.</p>';
            }
            if (lockerStatusText) lockerStatusText.textContent = `Capacity: ${snapshot.size} / 10 items (Example Limit)`; // Update based on actual limits
        });
    } catch (error) {
        console.error("Error loading user media:", error);
        if (lockerMediaDisplay) lockerMediaDisplay.innerHTML = '<p class="text-center text-red-500">Error loading media.</p>';
    }
}


// --- 8. Initial App Load Sequence ---
document.addEventListener('DOMContentLoaded', () => {
    cacheDOMElements(); // Get references to all DOM elements once HTML is ready

    // Initial check for Gemini API Key to enable TTS button
    if (ttsButton && ttsStatus) {
        if (geminiApiKey && geminiApiKey !== '') {
            ttsButton.disabled = false;
            ttsStatus.textContent = 'Status: Ready for Announcement';
        } else {
            ttsButton.disabled = true;
            ttsStatus.textContent = 'Status: Gemini API Key missing';
        }
    }
    
    // You would add actual TTS generation logic here for window.generateAndSpeak
    window.generateAndSpeak = async () => {
        if (!ttsInput || ttsInput.value.trim() === '') {
            alert('Please enter text to announce.');
            return;
        }
        if (ttsButton) ttsButton.disabled = true;
        if (ttsStatus) ttsStatus.textContent = 'Status: Generating audio...';

        try {
            // This would typically call your Netlify Function
            // For now, it's a placeholder. Replace with actual fetch to your /api/generate-tts
            const response = await fetch('/.netlify/functions/generate-tts', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ text: ttsInput.value }),
            });

            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.error || 'Failed to generate TTS');
            }

            const audioBlob = await response.blob();
            const audioUrl = URL.createObjectURL(audioBlob);
            const audio = new Audio(audioUrl);
            audio.play();
            if (ttsStatus) ttsStatus.textContent = 'Status: Playing announcement!';
            audio.onended = () => {
                if (ttsStatus) ttsStatus.textContent = 'Status: Ready for Announcement';
                if (ttsButton) ttsButton.disabled = false;
            };
        } catch (error) {
            console.error('TTS Generation Error:', error);
            if (ttsStatus) ttsStatus.textContent = `Status: Error - ${error.message}`;
            if (ttsButton) ttsButton.disabled = false;
            alert(`Failed to announce: ${error.message}`);
        }
    };

    // Placeholder for QR code generation function
    if (qrcodeContainer && loginQrIdInput) {
        // This assumes you have a QR code library loaded (e.g., qrcode.min.js via <script> tag or npm)
        // If you are using a global QR code library, it might be window.QRCode
        try {
            if (typeof QRCode !== 'undefined') { // Check if QRCode library is globally available
                // Assuming loginQrIdInput might hold a dynamic user ID to be shared
                const qrContent = loginQrIdInput.value || window.location.href; // Default to current URL if no ID
                new QRCode(qrcodeContainer, {
                    text: qrContent,
                    width: 96,
                    height: 96,
                    colorDark : "#000000",
                    colorLight : "#ffffff",
                    correctLevel : QRCode.CorrectLevel.H
                });
            } else {
                 qrcodeContainer.innerHTML = '<p class="text-xs text-gray-500">QR Lib not loaded.</p>';
                 console.warn("QRCode library not found. QR code generation will not work.");
            }
        } catch (e) {
            console.error("QR Code generation error:", e);
            qrcodeContainer.innerHTML = '<p class="text-xs text-red-500">QR Gen Error.</p>';
        }
    }
});

// Assuming your index.html has a Zeus avatar that you want to animate
function animateZeusAvatar() {
    const zeusAvatar = document.getElementById('zeus-avatar-svg');
    if (!zeusAvatar) return;

    zeusAvatar.style.opacity = '1';
    let position = 0; // Start at the bottom
    let direction = -1; // -1 for up, 1 for down

    function fly() {
        position += direction * 2; // Move 2px per step
        if (position <= -100 || position >= 0) { // If hits top or bottom (adjust values as needed)
            direction *= -1; // Reverse direction
        }
        zeusAvatar.style.transform = `translateY(${position}px)`;
        requestAnimationFrame(fly);
    }
    // Commenting out for now as it's an endless animation, might cause performance issues
    // if not managed properly or is not meant to be always-on.
    // requestAnimationFrame(fly);
}
// document.addEventListener('DOMContentLoaded', animateZeusAvatar); // Uncomment to enable
// app.js - Your Main Application Logic

// --- 1. Firebase SDK Imports ---
// These import statements require the Firebase SDK to be installed in your project.
// You have successfully run 'npm install firebase qrcode.js'.
import { initializeApp } from 'firebase/app';
import { getAuth, onAuthStateChanged, signInWithEmailAndPassword, createUserWithEmailAndPassword, signOut, updatePassword as authUpdatePassword } from 'firebase/auth';
import { getFirestore, doc, getDoc, setDoc, onSnapshot, collection, addDoc, serverTimestamp, query, orderBy, limit, updateDoc } from 'firebase/firestore';
import { getStorage, ref as storageRef, uploadBytes, getDownloadURL, listAll } from 'firebase/storage';

// --- 2. Retrieve Firebase Config from env-config.js ---
// This assumes your netlify.toml is correctly setting window.__firebase_config
// and env-config.js is loaded BEFORE app.js in index.html.
const firebaseConfig = window.__firebase_config;
const geminiApiKey = window.GEMINI_API_KEY; // Assuming Gemini API key is also passed this way

// --- 3. Initial Configuration Check ---
if (!firebaseConfig || !firebaseConfig.apiKey) {
    console.error("ðŸ”¥ Error: Firebase configuration not found or incomplete. Check env-config.js and Netlify build process.");
    // Update loading overlay to show an error
    const loadingOverlay = document.getElementById('loading-overlay');
    if (loadingOverlay) {
        loadingOverlay.innerHTML = `
            <div class="text-center text-red-700">
                <p class="text-xl font-bold mb-2">Configuration Error!</p>
                <p>Firebase setup is incomplete. Check browser console for details.</p>
                <p class="text-sm mt-2">Is 'env-config.js' loaded? Are Netlify env vars correct?</p>
            </div>
        `;
        loadingOverlay.style.backgroundColor = 'rgba(255, 0, 0, 0.9)'; // More opaque red background
    }
    // Prevent further execution if config is critically missing
    throw new Error("Firebase configuration is missing or malformed. Cannot initialize app.");
}

// --- 4. Initialize Firebase App and Services ---
const app = initializeApp(firebaseConfig);
const auth = getAuth(app);
const db = getFirestore(app);
const storage = getStorage(app);

// Global variables for convenience (can be managed better in larger apps)
let currentUser = null;
let currentUserID = null;
let userIsPro = false; // Flag for PRO membership status

console.log("âœ… Firebase app initialized successfully!");
console.log("Project ID:", firebaseConfig.projectId);
// Update debug info in HTML
document.addEventListener('DOMContentLoaded', () => {
    document.getElementById('debug-firebase-config').querySelector('span').textContent = firebaseConfig.projectId ? 'Loaded' : 'Error';
    document.getElementById('debug-app-id').querySelector('span').textContent = firebaseConfig.appId || 'N/A';
});


// --- 5. UI Element References (Caching for performance) ---
// It's good practice to get references to elements once the DOM is ready.
// This is done in the DOMContentLoaded listener further down.
let loadingOverlay, mainContent, paywallContent, loginModal, accountModal;
let headerAuthBtn, accountBtn, adminBtn;
let userStatusDisplay, userIdDisplay, accountUID, accountPremiumStatus;
let ttsButton, ttsStatus, ttsInput;
let lockerUploadBtn, mediaFileInput, lockerMediaDisplay, lockerStatusText;
let loginQrIdInput, qrcodeContainer; // For QR elements
let zeusAvatar; // For the Zeus avatar SVG

// Function to safely get elements after DOM is loaded
function cacheDOMElements() {
    loadingOverlay = document.getElementById('loading-overlay');
    mainContent = document.getElementById('main-content');
    paywallContent = document.getElementById('paywall-content');
    loginModal = document.getElementById('login-modal');
    accountModal = document.getElementById('account-modal');
    headerAuthBtn = document.getElementById('header-auth-btn');
    accountBtn = document.getElementById('account-btn');
    adminBtn = document.getElementById('admin-btn');
    userStatusDisplay = document.getElementById('user-status-display');
    userIdDisplay = document.getElementById('user-id-display');
    accountUID = document.getElementById('account-uid');
    accountPremiumStatus = document.getElementById('account-premium-status');
    ttsButton = document.getElementById('tts-button');
    ttsStatus = document.getElementById('tts-status');
    ttsInput = document.getElementById('tts-input');
    lockerUploadBtn = document.getElementById('locker-upload-btn');
    mediaFileInput = document.getElementById('media-file-input');
    lockerMediaDisplay = document.getElementById('locker-media-display');
    lockerStatusText = document.getElementById('locker-status-text');
    loginQrIdInput = document.getElementById('login-qr-id-input');
    qrcodeContainer = document.getElementById('qrcode-container');
    zeusAvatar = document.getElementById('zeus-avatar-svg'); // Cache Zeus avatar
}


// --- 6. Core Application Functions ---

/**
 * Hides the loading overlay and shows appropriate content based on user state.
 */
function hideLoadingOverlayAndShowContent() {
    if (loadingOverlay) {
        loadingOverlay.classList.add('hidden');
    }

    // Logic to show main content or paywall
    if (currentUser && userIsPro) {
        mainContent.classList.remove('hidden');
        paywallContent.classList.add('hidden');
    } else if (currentUser && !userIsPro) {
        // Logged in but not Pro, show main content but some features might be locked
        mainContent.classList.remove('hidden');
        paywallContent.classList.add('hidden');
        // You might want to display a message or disable PRO features here
    }
    else { // Not logged in
        mainContent.classList.add('hidden');
        paywallContent.classList.remove('hidden');
    }
}

/**
 * Toggles the visibility of the login modal.
 * @param {boolean} show - True to show, false to hide.
 */
window.toggleLoginModal = (show) => {
    if (loginModal) {
        if (show) loginModal.classList.remove('hidden');
        else loginModal.classList.add('hidden');
    }
};

/**
 * Toggles the visibility of the account modal.
 * @param {boolean} show - True to show, false to hide.
 */
window.toggleAccountModal = (show) => {
    if (accountModal) {
        if (show) accountModal.classList.remove('hidden');
        else accountModal.classList.add('hidden');
    }
};

/**
 * Authenticates a user with email and password.
 */
window.logIn = async () => {
    const email = document.getElementById('login-email').value;
    const password = document.getElementById('login-password').value;
    const loginError = document.getElementById('login-error');

    if (!email || !password) {
        loginError.textContent = "Email and password are required.";
        return;
    }

    try {
        loginError.textContent = ""; // Clear previous errors
        await signInWithEmailAndPassword(auth, email, password);
        console.log("User logged in successfully!");
        toggleLoginModal(false); // Close modal on success
    } catch (error) {
        console.error("Login failed:", error.code, error.message);
        loginError.textContent = `Login failed: ${error.message}`;
    }
};

/**
 * Registers a new user with email and password.
 */
window.register = async () => {
    const email = document.getElementById('login-email').value;
    const password = document.getElementById('login-password').value;
    const loginError = document.getElementById('login-error');

    if (!email || !password || password.length < 6) {
        loginError.textContent = "Email and a password of at least 6 characters are required.";
        return;
    }

    try {
        loginError.textContent = ""; // Clear previous errors
        const userCredential = await createUserWithEmailAndPassword(auth, email, password);
        console.log("User registered successfully:", userCredential.user.uid);
        // Create a user profile in Firestore
        await setDoc(doc(db, "users", userCredential.user.uid), {
            uid: userCredential.user.uid,
            email: userCredential.user.email,
            nickname: email.split('@')[0], // Default nickname
            isPro: false,
            createdAt: serverTimestamp()
        });
        toggleLoginModal(false); // Close modal on success
    } catch (error) {
        console.error("Registration failed:", error.code, error.message);
        loginError.textContent = `Registration failed: ${error.message}`;
    }
};

/**
 * Logs out the current user.
 */
window.logOut = async () => {
    try {
        await signOut(auth);
        console.log("User logged out successfully!");
        // UI updates handled by onAuthStateChanged listener
    } catch (error) {
        console.error("Logout failed:", error.code, error.message);
    }
};

/**
 * Saves the user's nickname to Firestore.
 */
window.saveAccountNickname = async () => {
    const nicknameInput = document.getElementById('account-nickname');
    if (!currentUser || !nicknameInput) return;

    const newNickname = nicknameInput.value.trim();
    if (newNickname === '') {
        alert("Nickname cannot be empty.");
        return;
    }

    try {
        const userDocRef = doc(db, "users", currentUser.uid);
        await updateDoc(userDocRef, { nickname: newNickname });
        console.log("Nickname updated successfully!");
        alert("Nickname saved!");
    } catch (error) {
        console.error("Error updating nickname:", error);
        alert(`Failed to save nickname: ${error.message}`);
    }
};

/**
 * Updates the user's password.
 */
window.updateUserPassword = async () => {
    const newPasswordInput = document.getElementById('account-new-password');
    const passwordError = document.getElementById('account-password-error');
    if (!currentUser || !newPasswordInput) return;

    const newPassword = newPasswordInput.value;
    if (newPassword.length < 6) {
        passwordError.textContent = "Password must be at least 6 characters.";
        return;
    }

    try {
        passwordError.textContent = "";
        await authUpdatePassword(currentUser, newPassword);
        console.log("Password updated successfully!");
        alert("Password updated! Please log in again with your new password.");
        await signOut(auth); // Force re-login after password change
        toggleAccountModal(false);
        toggleLoginModal(true);
    } catch (error) {
        console.error("Error updating password:", error);
        passwordError.textContent = `Failed to update password: ${error.message}`;
    }
};


// Placeholder for other functions - you will fill these in!
window.toggleAdminModal = (show) => { console.log('Admin modal functionality not implemented yet.'); /* Implement actual logic */ };
window.toggleCashAppModal = (show) => { console.log('CashApp modal functionality not implemented yet.'); /* Implement actual logic */ };
window.startZeusNarratorTour = () => { console.log('Zeus Narrator Tour not implemented yet.'); /* Implement actual logic */ };
window.toggleSportsDataModal = (show) => { console.log('Sports Data modal functionality not implemented yet.'); /* Implement actual logic */ };
window.copyQrCodeText = () => {
    if (loginQrIdInput && loginQrIdInput.value) {
        navigator.clipboard.writeText(loginQrIdInput.value)
            .then(() => {
                alert('User ID copied to clipboard!');
            })
            .catch(err => {
                console.error('Failed to copy text: ', err);
            });
    }
};

window.sendMessage = async (type, content) => {
    if (!currentUserID) {
        alert("You must be logged in to send messages.");
        return;
    }
    const messageInput = document.getElementById('message-input');
    const chatModeToggle = document.getElementById('chat-mode-toggle');
    const recipientIdInput = document.getElementById('recipient-id-input');

    let messageText = messageInput.value.trim();
    if (messageText === '') return;

    try {
        await addDoc(collection(db, "chatMessages"), {
            uid: currentUserID,
            senderNickname: (await getDoc(doc(db, "users", currentUserID))).data()?.nickname || 'Anon',
            text: messageText,
            timestamp: serverTimestamp(),
            type: type, // 'text', 'VIDEO_REQUEST', etc.
            chatType: chatModeToggle.value, // 'public' or 'private'
            recipientId: chatModeToggle.value === 'private' ? recipientIdInput.value : null
        });
        messageInput.value = ''; // Clear input
    } catch (error) {
        console.error("Error sending message:", error);
        alert("Failed to send message.");
    }
};

window.toggleChatMode = () => {
    const chatModeToggle = document.getElementById('chat-mode-toggle');
    const recipientContainer = document.getElementById('recipient-container');
    const recipientIdInput = document.getElementById('recipient-id-input');
    const videoCallBtn = document.getElementById('video-call-btn');

    if (chatModeToggle.value === 'private') {
        if (recipientContainer) recipientContainer.classList.remove('hidden');
        if (recipientIdInput) recipientIdInput.classList.remove('hidden');
        if (videoCallBtn) videoCallBtn.classList.remove('hidden');
    } else {
        if (recipientContainer) recipientContainer.classList.add('hidden');
        if (recipientIdInput) recipientIdInput.classList.add('hidden');
        if (videoCallBtn) videoCallBtn.classList.add('hidden');
        if (recipientIdInput) recipientIdInput.value = ''; // Clear recipient when switching to public
    }
};

window.handleFileUpload = async () => {
    if (!currentUser) {
        console.warn("Cannot upload: User not logged in.");
        alert("Please log in to upload media.");
        return;
    }
    if (!mediaFileInput || mediaFileInput.files.length === 0) {
        console.warn("No file selected for upload.");
        return;
    }
    const file = mediaFileInput.files[0];
    const filePath = `user_media/${currentUser.uid}/${file.name}`;
    const fileRef = storageRef(storage, filePath);

    try {
        console.log(`Uploading ${file.name}...`);
        // You might want to show a loading indicator here
        await uploadBytes(fileRef, file);
        const fileURL = await getDownloadURL(fileRef);
        console.log("File uploaded, URL:", fileURL);

        // Save file metadata to Firestore (e.g., in a 'user_files' subcollection)
        await addDoc(collection(db, "users", currentUser.uid, "media"), {
            name: file.name,
            url: fileURL,
            uploadedAt: serverTimestamp(),
            type: file.type
        });
        console.log("File metadata saved to Firestore.");
        alert("File uploaded successfully!");
        loadUserMedia(); // Refresh media display
    } catch (error) {
        console.error("File upload failed:", error);
        alert(`Upload failed: ${error.message}`);
    }
};


// --- 7. Real-time Listeners and Data Loading ---

// Listen for authentication state changes
onAuthStateChanged(auth, async (user) => {
    currentUser = user; // Update global user object
    currentUserID = user ? user.uid : null;

    if (user) {
        console.log("User state changed: Logged in", user.uid);
        if (userStatusDisplay) userStatusDisplay.textContent = 'Logged In';
        if (userIdDisplay) userIdDisplay.textContent = user.uid.substring(0, 8); // Display first 8 chars
        if (headerAuthBtn) headerAuthBtn.classList.add('hidden');
        if (accountBtn) accountBtn.classList.remove('hidden');
        if (lockerUploadBtn) lockerUploadBtn.disabled = false;
        if (accountUID) accountUID.textContent = user.uid;

        // Fetch user profile from Firestore to get isPro status
        const userDocRef = doc(db, "users", user.uid);
        const userDocSnap = await getDoc(userDocRef);
        if (userDocSnap.exists()) {
            const userData = userDocSnap.data();
            userIsPro = userData.isPro || false; // Default to false if not set
            if (accountPremiumStatus) accountPremiumStatus.textContent = userIsPro ? 'PRO Member' : 'Standard User';
            if (document.getElementById('account-nickname') && userData.nickname) {
                 document.getElementById('account-nickname').value = userData.nickname;
            }
        } else {
            console.warn("User profile not found in Firestore, creating basic entry.");
            // This case should ideally be covered by register(), but good fallback
            await setDoc(userDocRef, {
                uid: user.uid,
                email: user.email,
                nickname: user.email.split('@')[0],
                isPro: false,
                createdAt: serverTimestamp()
            }, { merge: true }); // Use merge to not overwrite existing fields
            userIsPro = false;
            if (accountPremiumStatus) accountPremiumStatus.textContent = 'Standard User';
            if (document.getElementById('account-nickname')) document.getElementById('account-nickname').value = user.email.split('@')[0];
        }

        // After all user data is loaded and state is set
        hideLoadingOverlayAndShowContent();
        loadActiveUsers();
        loadLiveFeed();
        loadChatMessages();
        loadCommunityScoreboard();
        loadUserMedia(); // Load user's media for locker
        // Other data loads that require authentication
    } else {
        console.log("User state changed: Logged out");
        if (userStatusDisplay) userStatusDisplay.textContent = 'Logged Out';
        if (userIdDisplay) userIdDisplay.textContent = '';
        if (headerAuthBtn) headerAuthBtn.classList.remove('hidden');
        if (accountBtn) accountBtn.classList.add('hidden');
        if (lockerUploadBtn) lockerUploadBtn.disabled = true;
        if (accountUID) accountUID.textContent = 'N/A';
        if (accountPremiumStatus) accountPremiumStatus.textContent = 'N/A';
        userIsPro = false;

        // After auth state is determined
        hideLoadingOverlayAndShowContent();
        loadActiveUsers(); // Active users might still be public
        loadLiveFeed(); // Live feed might still be public
        // Clear private data displays
        if (lockerMediaDisplay) lockerMediaDisplay.innerHTML = '<p class="text-center text-gray-500">Log in to view your media.</p>';
    }
});


// Live Feed Listener (assuming 'liveFeed' collection is publicly readable)
function loadLiveFeed() {
    const liveFeedRef = doc(db, "liveFeed", "latestScore"); // Document ID 'latestScore'
    const latestDataEl = document.getElementById('latest-data');
    const dataStreamEl = document.getElementById('data-stream');

    if (!latestDataEl || !dataStreamEl) return; // Prevent errors if elements aren't found

    onSnapshot(liveFeedRef, (docSnap) => {
        if (docSnap.exists()) {
            const data = docSnap.data();
            latestDataEl.textContent = data.score || "No score update.";
            dataStreamEl.textContent = JSON.stringify(data, null, 2);
            console.log("Live Feed updated:", data);
        } else {
            latestDataEl.textContent = "No live data available.";
            dataStreamEl.textContent = "No 'latestScore' document found in 'liveFeed' collection.";
            console.warn("No 'latestScore' document in 'liveFeed' collection.");
        }
    }, (error) => {
        console.error("Error loading live feed:", error);
        const statusMessageEl = document.getElementById('status-message');
        const statusMessageContainerEl = document.getElementById('status-message-container');
        if (statusMessageEl && statusMessageContainerEl) {
            statusMessageEl.textContent = `Error loading live feed: ${error.message}`;
            statusMessageContainerEl.classList.remove('hidden');
        }
    });
}

// Active Users Listener (assuming 'presence' collection is publicly readable)
function loadActiveUsers() {
    const activeUsersList = document.getElementById('active-users-list');
    if (!activeUsersList) return;

    const q = query(collection(db, "presence"), orderBy("lastSeen", "desc"), limit(10)); // Order by last seen, limit to 10
    onSnapshot(q, (snapshot) => {
        activeUsersList.innerHTML = ''; // Clear previous list
        snapshot.forEach((doc) => {
            const userData = doc.data();
            if (userData.nickname && userData.lastSeen) { // Ensure nickname and lastSeen exist
                const li = document.createElement('li');
                li.className = 'flex items-center space-x-2 p-2 bg-gray-50 rounded-md';
                // Calculate time difference for 'min ago'
                const lastSeenDate = userData.lastSeen.toDate();
                const minutesAgo = Math.round((Date.now() - lastSeenDate) / 60000); // in minutes
                li.innerHTML = `
                    <span class="w-2 h-2 rounded-full ${minutesAgo < 5 ? 'bg-green-500' : 'bg-yellow-500'}"></span>
                    <span>${userData.nickname}</span>
                    <span class="text-xs text-gray-400">(${minutesAgo} min ago)</span>
                `;
                activeUsersList.appendChild(li);
            }
        });
        if (snapshot.empty) {
            activeUsersList.innerHTML = '<p class="text-center text-gray-500 py-4">No active users.</p>';
        }
    }, (error) => {
        console.error("Error loading active users:", error);
    });
}

// Chat Messages Listener (assuming 'chatMessages' collection is publicly readable/writable for now)
function loadChatMessages() {
    const chatMessagesEl = document.getElementById('chat-messages');
    if (!chatMessagesEl) return;

    const q = query(collection(db, "chatMessages"), orderBy("timestamp", "asc"), limit(50));
    onSnapshot(q, (snapshot) => {
        chatMessagesEl.innerHTML = ''; // Clear previous messages
        snapshot.forEach((doc) => {
            const msg = doc.data();
            const p = document.createElement('p');
            p.className = `text-sm ${msg.uid === currentUserID ? 'text-right text-metro-primary' : 'text-left text-gray-800'}`;
            const time = msg.timestamp ? new Date(msg.timestamp.toDate()).toLocaleTimeString() : '';
            p.innerHTML = `<span class="font-semibold">${msg.senderNickname || 'Anon'}</span> <span class="text-gray-500 text-xs">${time}</span>: ${msg.text}`;
            chatMessagesEl.appendChild(p);
        });
        chatMessagesEl.scrollTop = chatMessagesEl.scrollHeight; // Auto-scroll to latest
    }, (error) => {
        console.error("Error loading chat messages:", error);
    });
}

// Community Scoreboard Listener (assuming 'sportsData' is publicly readable)
function loadCommunityScoreboard() {
    const sportsDataDisplay = document.getElementById('sports-data-display');
    if (!sportsDataDisplay) return;

    const q = query(collection(db, "sportsData"), orderBy("timestamp", "desc"), limit(10));
    onSnapshot(q, (snapshot) => {
        sportsDataDisplay.innerHTML = '';
        if (snapshot.empty) {
            sportsDataDisplay.innerHTML = '<p class="text-center text-gray-500 py-8 col-span-full">No sports data submitted yet.</p>';
        } else {
            snapshot.forEach((doc) => {
                const data = doc.data();
                const div = document.createElement('div');
                div.className = 'bg-gray-50 p-4 rounded-lg shadow-sm border border-gray-200';
                div.innerHTML = `
                    <p class="font-semibold text-lg">${data.sport}: ${data.score}</p>
                    <p class="text-sm text-gray-600">${data.team1} vs ${data.team2}</p>
                    <p class="text-xs text-gray-400">Submitted by ${data.submittedBy || 'Anon'} on ${new Date(data.timestamp.toDate()).toLocaleString()}</p>
                `;
                sportsDataDisplay.appendChild(div);
            });
        }
    }, (error) => {
        console.error("Error loading scoreboard:", error);
    });
}


// Function to load user's uploaded media
async function loadUserMedia() {
    if (!currentUser) {
        if (lockerMediaDisplay) lockerMediaDisplay.innerHTML = '<p class="text-center text-gray-500">Log in to view your media.</p>';
        if (lockerStatusText) lockerStatusText.textContent = 'Capacity: Log in to see status.';
        return;
    }
    if (lockerMediaDisplay) lockerMediaDisplay.innerHTML = '<p class="text-center text-gray-500">Loading your media...</p>';
    if (lockerStatusText) lockerStatusText.textContent = 'Capacity: Checking...';

    try {
        const mediaCollectionRef = collection(db, "users", currentUser.uid, "media");
        const q = query(mediaCollectionRef, orderBy("uploadedAt", "desc"), limit(10)); // Limit to 10 for example
        onSnapshot(q, (snapshot) => {
            if (lockerMediaDisplay) lockerMediaDisplay.innerHTML = ''; // Clear previous media
            snapshot.forEach((doc) => {
                const media = doc.data();
                const div = document.createElement('div');
                div.className = 'relative group';
                // Basic image display, enhance with video/other types as needed
                if (media.type && media.type.startsWith('image/')) {
                    div.innerHTML = `<img src="${media.url}" alt="${media.name}" class="w-full h-32 object-cover rounded-lg shadow">`;
                } else {
                     div.innerHTML = `<a href="${media.url}" target="_blank" class="block w-full h-32 bg-gray-200 flex items-center justify-center rounded-lg shadow text-gray-600">Download ${media.name}</a>`;
                }
                if (lockerMediaDisplay) lockerMediaDisplay.appendChild(div);
            });
            if (snapshot.empty && lockerMediaDisplay) {
                lockerMediaDisplay.innerHTML = '<p class="text-center text-gray-500">No media uploaded yet.</p>';
            }
            if (lockerStatusText) lockerStatusText.textContent = `Capacity: ${snapshot.size} / 10 items (Example Limit)`; // Update based on actual limits
        });
    } catch (error) {
        console.error("Error loading user media:", error);
        if (lockerMediaDisplay) lockerMediaDisplay.innerHTML = '<p class="text-center text-red-500">Error loading media.</p>';
    }
}

// --- Zeus Avatar Animation Function ---
function animateZeusAvatar() {
    if (!zeusAvatar) return;

    zeusAvatar.style.opacity = '1';
    let position = 0; // Start at the bottom
    let direction = -1; // -1 for up, 1 for down

    function fly() {
        position += direction * 2; // Move 2px per step
        if (position <= -100 || position >= 0) { // If hits top or bottom (adjust values as needed)
            direction *= -1; // Reverse direction
        }
        zeusAvatar.style.transform = `translateY(${position}px)`;
        requestAnimationFrame(fly);
    }
    // Commenting out for now as it's an endless animation, might cause performance issues
    // if not managed properly or is not meant to be always-on.
    // requestAnimationFrame(fly); // Uncomment to enable the animation
}


// --- 8. Initial App Load Sequence ---
document.addEventListener('DOMContentLoaded', () => {
    cacheDOMElements(); // Get references to all DOM elements once HTML is ready

    // Initial check for Gemini API Key to enable TTS button
    if (ttsButton && ttsStatus) {
        if (geminiApiKey && geminiApiKey !== '') {
            ttsButton.disabled = false;
            ttsStatus.textContent = 'Status: Ready for Announcement';
        } else {
            ttsButton.disabled = true;
            ttsStatus.textContent = 'Status: Gemini API Key missing';
        }
    }
    
    // You would add actual TTS generation logic here for window.generateAndSpeak
    window.generateAndSpeak = async () => {
        if (!ttsInput || ttsInput.value.trim() === '') {
            alert('Please enter text to announce.');
            return;
        }
        if (ttsButton) ttsButton.disabled = true;
        if (ttsStatus) ttsStatus.textContent = 'Status: Generating audio...';

        try {
            // This would typically call your Netlify Function
            // For now, it's a placeholder. Replace with actual fetch to your /api/generate-tts
            const response = await fetch('/.netlify/functions/generate-tts', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ text: ttsInput.value }),
            });

            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.error || 'Failed to generate TTS');
            }

            const audioBlob = await response.blob();
            const audioUrl = URL.createObjectURL(audioBlob);
            const audio = new Audio(audioUrl);
            audio.play();
            if (ttsStatus) ttsStatus.textContent = 'Status: Playing announcement!';
            audio.onended = () => {
                if (ttsStatus) ttsStatus.textContent = 'Status: Ready for Announcement';
                if (ttsButton) ttsButton.disabled = false;
            };
        } catch (error) {
            console.error('TTS Generation Error:', error);
            if (ttsStatus) ttsStatus.textContent = `Status: Error - ${error.message}`;
            if (ttsButton) ttsButton.disabled = false;
            alert(`Failed to announce: ${error.message}`);
        }
    };

    // Placeholder for QR code generation function
    if (qrcodeContainer && loginQrIdInput) {
        // This assumes you have a QR code library loaded (e.g., qrcode.min.js via <script> tag or npm)
        // If you are using a global QR code library, it might be window.QRCode
        try {
            if (typeof QRCode !== 'undefined') { // Check if QRCode library is globally available
                // Assuming loginQrIdInput might hold a dynamic user ID to be shared
                const qrContent = loginQrIdInput.value || window.location.href; // Default to current URL if no ID
                new QRCode(qrcodeContainer, {
                    text: qrContent,
                    width: 96,
                    height: 96,
                    colorDark : "#000000",
                    colorLight : "#ffffff",
                    correctLevel : QRCode.CorrectLevel.H
                });
            } else {
                 qrcodeContainer.innerHTML = '<p class="text-xs text-gray-500">QR Lib not loaded.</p>';
                 console.warn("QRCode library not found. QR code generation will not work.");
            }
        } catch (e) {
            console.error("QR Code generation error:", e);
            qrcodeContainer.innerHTML = '<p class="text-xs text-red-500">QR Gen Error.</p>';
        }
    }

    // Call Zeus avatar animation if desired (currently commented out)
    animateZeusAvatar(); // Will not run the animation loop unless requestAnimationFrame(fly) is uncommented inside
});
